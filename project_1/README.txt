Δημήτριος Σιταράς	|
1115201800178 	 	|
———————————————————

► Οργάνωση Κώδικα:

    .
    ├── BashScript
    │   └── finder.sh
    ├── hashTableSaveWorkers
    │   ├── hashTableListSaveWorkers
    │   │   ├── hashTableListSaveWorkers.c
    │   │   └── hashTableListSaveWorkers.h
    │   ├── hashTableSaveWorkers.c
    │   └── hashTableSaveWorkers.h
    ├── hashTableUrl
    │   ├── hashTableListUrl
    │   │   ├── hashTableListUrl.c
    │   │   └── hashTableListUrl.h
    │   ├── hashTableUrl.c
    │   └── hashTableUrl.h
    ├── managerUtilities
    │   ├── managerUtilities.c
    │   └── managerUtilities.h
    ├── workersQueue
    │   ├── workersQueue.c
    │   └── workersQueue.h
    ├── output
    ├── Makefile
    ├── README.txt
    ├── worker.c
    └── managerΝlistener.c
    


► Γενικά:

    → Ο κώδικας είναι σχολιασμένος.

    → Πληρούνται όλες οι προϋποθέσεις/απαιτήσεις που αναγράφονται στην εκφώνηση της εργασίας.
    
    → Γίνεται το απαραίτητο Εrror Ηandling.

    → Όλη η μνήμη που δεσμεύεται δυναμικά κατά την εκτέλεση του προγράμματος, αποδεσμεύεται πλήρως
  	  ( Έχει ελεγχθεί μέσω valgrind στα μηχανήματα linux της σχολής).

    → Eντολή μεταγλώττισης: make (υπάρχει αρχείο Makefile)

    → Εντολή εκτέλεσης: ./sniffer [-p path]

    → make clean, για την διαγραφή των παραγόμενων από την μεταγλώττιση αρχείων καθώς και των παραγόμενων (απο τους workers) .out αρχείων που βρίσκονται στον φάκελο output/ .

    → make clean-output, για την διαγραφή μόνο των παραγόμενων (απο τους workers) .out αρχείων που βρίσκονται στον φάκελο output/ .

    → Τα .out αρχεία που παράγονται από τους workers αποθηκεύονται στον φάκελο output/ .

    → To finder.sh για να εκτελεστεί πρέπει να έχει τα αντίστοιχα δικαιώματα (chmod 777 finder.sh) .

    → Εντολή εκτέλεσης Bash Script αρχείου:  ./finder.sh [com gr org ...] .


▪ Ζητούμενο 1
———————————————

    → Πρωτόκολλο επικοινωνίας Manager - Listener

        O Manager επικοινωνεί με την διεργασία Listener μέσω pipe, συγκεκριμένα για να το πετύχω αυτό,
        απο την πλευρά του Listener, έχω συνδέσει, με χρήση της dup2(), το standard output της διεργασίας με το pipe, 
        έτσι ώστε η έξοδος της inotifywait ( η οποία εκτελείται με χρήση της execlp() ) να γράφεται
        στο pipe. Από πλευράς Manager, αρχικά κλείνω την μεριά του pipe στην οποία "γράφει" ο Listener. Στη συνέχεια,
        σε πρώτη φάση έχω μια read(), στην οποία μπλοκάρει ο Manager περιμένοτας τον Listener να τον ενημερώσει για ένα σύνολο αρχείων που ανίχνευσαι,
        έφοσον γράψει ο Listener στο pipe, o Manager διαβάζει 1 byte απο την συγκεκριμένη read() ( το οποίο το αποθηκέυω σε μια μεταβλητή ) 
        και έπειτα μέσω της ioctl() (με flag FIONREAD) βρίσκω πόσα διαθέσιμα ακόμα bytes υπάρχουν στο pipe (για διάβασμα), 
        δεσμεύοντας έτσι δυναμικά τον buffer ( συνολικά όσα bytes μου επεστρεψε η ioctl() + το byte που προηγουμένως διάβασα + ένα byte για τον χαρακτήρα '\0' ).
        Τέλος, μέσω ακόμα μιας read() διαβάζω από το pipe τα υπόλοιπα bytes, αποθηκεύοντας τα στον παραπάνω δυναμικά δεσμευμένο buffer, ακολούθως κάνω την απαραίτητη
        προεπεξεργασία, στέλνω τα ονόματα των αρχείων που έλαβε ο Manager στους Workers και ο Manager ξάνα μπλοκάρει στην read() περιμένοτας για
        νέα ενημέρωση απο τον Listener. Συνεπώς, ό,τι γράφεται στο pipe από τον Listener ( για ένα σύνολο αρχείων που ανιχνεύει στο directory που παρακολουθεί ) λαμβάνεται από τον Manager και αυτός με την σειρά του ενημέρωνει τους Workers.
        Σημειώνω πως κάνοντας μια μαζική μεταφορά αρχείων (π.χ. mv *.txt input/ ) στο directory που παρακαλουθεί η inotifywait, έστω ότι μεταφέρω 10 νέα αρχεία, είναι απροσδίοριστο πως θα τα 
        ανιχνεύσει η inotifywait και επομένως πως θα τα γράψει στο pipe, συγκεκριμένα δεν θα ανιχνέυσει και επομένως δεν θα γράψει απαραίτητα και τα 10 ονόματα αρχείων με την μια στο pipe, 
        αλλά πολλές φορές τα ανιχνεύει και τα γράφει "σε πακέτα", για παραδειγμα 2 την 1η φορά, 3 την 2η φορά, 4 την 3η φορα και 1 την 4η φορά (2-3-4-1), αυτό
        βέβαια δεν αποτελεί πρόβλημα καθώς ο Manager (για το συγκεκριμένο παράδειγμα) θα ενημερωθεί πρώτα για τα 2 ονόματα αρχείων, θα τα στείλει στους Workers, μετά για τα υπόλοιπα 3 ονόματα, θα τα στείλει στους Workers ... κτλ.

    → Δομές Δεδομένων

        Υλοποιήσα και χρησιμοποίησα τις παρακάτω δομές δεδομένων:

        - Ουρά (Queue) ( της οποίας η υλοποίηση βρίσκεται στον φάκελο workersQueue/ ) προκειμένου να κραταώ την πληροφορία για τους διαθέσιμους κάθε
          φορά workers και να δημιουργώ νέους σε περίπτωση που δεν υπάρχει κανένας διαθέσιμος. Σε αυτήν αποθηκεύω μόνο τα pids των αντίστοιχων Workers. 
          Συγκεκριμένα, σε αυτήν "μαζεύω" τους διαθέσιμους Workers ( που έχουν μπει σε κατάσταση stopped μετά από SIGSTOP στον ευατό τους ), 
          καλώντας την collectAvailableWorkers() (αφ' ότου βέβαια σηκωθεί το αντίστοιχο flag μέσα στον signal handler που έχω ορίσει για το SIGCHLD),
          η οποία κάνει χρήση της συνάρτησης waitpid(), μέσα σε μια while() με τις κατάλληλες παραμέτρους και flags, 
          προκειμένου να "μαζέψει" ένα - ένα όλα τα pids όλων των stopped Workers και να τα κανει push στην εν λόγω ουρά.
          Αυτή η διαδικασία γίνεται σε 3 σημεία στον Manager: 

            1) εκεί όπου γίνεται interrupted η read() (βλ. γραμμή 157 στο managerΝlistener.c ) από ένα σήμα (ή και πολλά που έρχονται ταυτόχρονα).
            
            2) μετά ακριβώς από την αποστολή ενός ονόματος αρχείου σε έναν Worker (βλ. γραμμή 244 στο managerΝlistener.c ).

            2) και στην περίπτωση που ο Manager λάβει σήμα SIGINT και ο αριθμό των κόμβων της ουράς είναι διαφορετικός από τον αριθμό τον κόμβων στο hash table (βλ. γραμμή 123 στο managerΝlistener.c ).
               ( ώστε πρωτού "σκοτώσει" μέσω SIGKILL όλες τις Workers διεργασίες, περιμένει εώς ότου όλες να είναι σε κατάσταση stopped )


          
          Κάθε φορά που ο Manager πρόκειται να στείλει ένα όνομα αρχείου κάνει pop έναν Worker από την Queue (παίρνοντας έτσι το pid του),
          όπως ανέφερα και παραπάνω, αν όμως η ουρά είναι άδεια ο Manager δημιουργεί έναν Worker, τον κάνει push στην ουρά και ακουλούθως pop
          προκειμένου να του στέιλει το αντίστοιχο όνομα.
        
        - Δυο πίνακες κατακερματισμού (οι 2 διαφορετικές υλοποιήσεις βρίσκονται στους φακέλους hashTableSaveWorkers/ και hashTableListUrl/ ) οι οποίοι έχουν
          υλοποιηθεί με χωριστές αλυσίδες λιστών (separate chaining with linked lists), δηλαδή κάθε bucket τους 
          δείχνει σε μια συνδεδεμένη λίστα από nodes, που έχουν την ίδια τιμή συνάρτησης κατακερματισμού.

            → Η υλοποίηση που βρίσκεται στον φάκελο hashTableSaveWorkers/ χρησιμοποιείται στον Manager ώστε να αποθηκεύω πληροφορίες για κάθε 
              έναν Worker και επομένως να μπορώ να τις προσπελάσω γρήγορα, συγκεκριμένα αποθηκεύω τα pids των workers, τα ονόματα των αντίστοιχων named pipes (fifos) που δημιουργούνται
              (προκείμενου να μπορέσω να τα κλείσω κατά τον τερματισμό του προγράμματος) και τα file descriptors που δημιουργούνται μετά το open των
              αντίστοιχων fifos. Συνεπώς, κάθε φορά που ο Manager πρόκειται να στείλει ένα όνομα αρχείου κάνει pop έναν Worker από την Queue, έπειτα κάνει μια αναζήτηση
              στο hash table με βάση το pid και παίρνει σχετικό το file descriptor του, το οποίο αντιστοιχεί στην fifo που χρησιμοποιείται για την επικοινωνία του Manager με τον συγκεκριμένο
              αυτόν Worker.
            
            → Η υλοποίηση που βρίσκεται στον φάκελο hashTableUrl/ χρησιμοποιείται στον Worker ώστε να αποθηκεύω τα URLs locations και τον αντίστοιχο αριθμό εμφανίσεών τους από το δοθεν αρχείο, γράφοντας
              όλη αυτήν την αποθηκευμένη πληροφορία στο αντίστοιχο αρχείο .out .
              Πιο συγκεκριμένα, κάθε φορά που ο Worker ολοκληρώσει το parsing ενός URL location που βρίσκει στο δοθέν αρχείο καλεί την συνάρτησης htUniqueInsertUrl() 
              η οποία κάνει ένα search ώστε να ελεγχθεί αν υπάρχει ήδη το συγκεκριμένο URL location στο hash table, αν ναι τότε, δεν το ξανα καταχωρεί, αλλά απλά αυξάνει τον αντίστοιχο αριθμό τον εμφανίσεων του,
              αν όχι τότε καταχωρεί το νέο αυτό URL location και θέτει τον αντίστοιχο αριθμό τον εμφανίσεων του ίσο με 1.
              Τέλος, όταν ολοκληρωσεί το διάβασμα του δοθέν αρχείου και δημιουργησεί το αντίστοιχο .out αρχείο τότε καλείται η htWriteUrl() ώστε να γράψει στο .out άρχειο αυτό
              όλα τα URLs locations που αποθηκεύτηκαν στο hash table καθώς και τον αντίστοιχο αριθμό εμφανίσεών τους.

    → Διαχείριση Αρχείου από τον Worker

      O Worker αφού διαβάσει το όνομα του αρχείου από το named pipe (fifo), εκτελεί την απαραίτητη προεπεξεργασία, και ανοίγει το δοθέν
      αρχείο διαβάζοντας έναν προς έναν τους χαρακτήρες του μέχρι το τέλους του. Σε αυτή την loop ( do{ }while(); ) ο Worker κάνει ουσιαστικά
      parsing τα URLs locations που περιέχονται στο αρχείο. Συγκεκριμένα, σε πρώτη φάση ανιχνεύει το string "http://", με χρήση κατάλληλων flags, και στην 
      συνέχεια (εφόσον εννοείται το ανίχνευσαι) ξεκινάει να κάνει parsing το location του url, αγνοώντας "www.", αν βέβαια υπάρχει. Μόλις ολοκληρώσει
      το parsing ενός url location το εισάγει στο hash table (βλ. στο αρχείο worker.c γραμμή 141), με τρόπο που περιέγραψα παραπάνω. Όταν τελείωσει με το 
      διάβασμα του αρχείου (έχοντας εισάγει πλέον όλα τα URLs locations που περιέχει στο hash table) δημιουργεί ένα νέο αντίστοιχο αρχείο στον φάκελο output/,
      προσθέτοντας απλά στο αρχικό όνομα την κατάληξη .out (π.χ. output/10.txt.out) και τέλος καλεί την htWriteUrl() ώστε να γράψει στο .out αρχείο όλα τα URLs locations 
      που αποθηκεύτηκαν στο hash table καθώς και τον αντίστοιχο αριθμό εμφανίσεών τους.
      

    ► Σημειώσεις

        → Έχω βάλει τα write() και τα open() system calls που πραγματοποιούνται από τον Manager στην ακόλουθη while:

          while ( ( ... = system_call() ) == -1 && errno == EINTR)
            continue;
        
          ώστε να μην γίνονται interrupt από signals που λαμβάνονται.
        
        → Για κάθε Worker δημιουργώ ένα ξεχωριστό named pipe (fifo), για την επικοινωνία του με τον Manager.

        → Τα named pipes (fifos) παραμένουν ενεργά ακόμα και όταν οι αντίστοιχοι workers είναι σε κατάσταση stopped.
          "Καταστρέφονται" μόνο κατά τον τερματισμό του προγράμματος από τον Manager (μετά την λήψη SIGINT σήματος).
        
        → Ο Manager μετά την λήψη SIGINT σήματος, πρωτού "σκοτώσει" μέσω SIGKILL όλες τις Workers διεργασίες, περιμένει εώς ότου
          όλες να είναι σε κατάσταση stopped ( να έχουν τελείωσει δηλαδή όλες οι διεργασίες Worker την διαχείριση του αρχείου που τους έχει ανατεθεί ) .
  
        → Το max length που μπορεί να έχει ένα URL location είναι 2048, επομένως προκειμένου να το αποθηκεύσω ορίζω έναν στατικό πίνακα μεγέθους 2048 (char url[2048]).

        → το hash table που αποθηκεύει τις πληροφορίες για τους Workers ( htWorkers ) στον Μanager αρχικοποιείται με 30 buckets.

        → το hash table που αποθηκεύει τις πληροφορίες για τα URLs ( htUrls ) στον Worker αρχικοποιείται με 50 buckets.

        → Τα δυο hash tables διαφέρουν ουσιαστικά, πέρα από την πληροφορία την οποία αποθηκεύουν, ως προς την hash function και ως προς την συνάρτηση εισαγωγής.

        → Κάθε φορά που ο Manager δημιουργεί έναν νέο Worker τότε το pid του είσαγεται (push) κατευθέιαν στην ουρά και αντίστοιχα ο Worker την πρώτη φορά που εκτελείται δεν κάνει SIGSTOP στον ευατό του.

        → Η διαχείριση των αρχείων γίνεται με low-level IO όπως ζητείται και στην εκφώνηση.



▪ Ζητούμενο 2
———————————————

  Αρχικά, καταχωρώ όλα τα tlds που δίνονται από το command line στον πίνακα tlds αρχικοποιώντας παράλληλα και τον πίνακα counters,
  όπου η κάθε θέση του αντιστοιχεί σε ένα tld. Στη συνέχεια, παίρνω όλα τα .out αρχεία και τα διατρέχω γραμμή-γραμμή, παίρνοντας κάθε
  φορά το tld και τον αντίστοιχο αριθμό εμφάνισεων του, κάνοντας έπειτα μια αναζήτηση βρίσκω το index στον πίνακα με τα tlds και προσθέτω
  τον αριθμό εμφάνισεων στην αντίστοιχη θέση στον πίνακα counters.
  Τέλος, εκτυπώνω τα περιεχόμενα των δύο πινάκων (tlds και counters) στην παρακάτω μορφή:

    tld1 sumOfAppearances
    tld2 sumOfAppearances
    tld3 sumOfAppearances
    ...


► Σημειώσεις

  → Τα .out αρχεία πρέπει να βρίσκονται στον ίδιο φάκελο με το finder.sh.

  → Αν δεν δωθούν καθόλου ορίσματα, το script τερματίζεται εμφανίζοντας μήνυμα λάθους.
